function [M,param] = dasmtx3(SIG,x,y,z,varargin)

%DASMTX3   Delay-and-sum matrix for 3-D imaging with a matrix array
%   M = DASMTX3(SIG,X,Y,Z,DELAYS,PARAM) returns the numel(X)-by-numel(SIG)
%   delay-and-sum DAS matrix. The matrix M can be used to beamform SIG (RF
%   or I/Q signals) at the points specified by X, Y, and Z.
%
%   Because the signals in SIG are not required (only its size is needed)
%   to create M, the following syntax is recommended:
%       M = DASMTX3(size(SIG),X,Y,Z,DELAYS,PARAM)
%   !IMPORTANT! -- With this syntax, use M = DASMTX3(1i*size(SIG),...) to
%   return a complex DAS matrix for I/Q data.
%
%   NOTE: SIG must be a 2-D or 3-D array (the 3rd dimension is ignored).
%         Or, size(SIG) must be a two- or three-component vector (the 3rd
%         component is ignored). The first dimension (i.e. each column)
%         corresponds to a single RF or I/Q signal over (fast-) time, with
%         the COLUMN #k corresponding to PARAM.elements #k.
%
%   DASMTX3 returns the same results as DAS3.
%       1) using DAS3:
%           bfSIG = das3(SIG,x,y,z,delays,param,method);
%       2) using DASMTX3:
%           M = dasmtx3(size(SIG),x,y,z,delays,param,method);
%           bfSIG = M*SIG(:);
%           bfSIG = reshape(bfSIG,size(x));
%
%   DELAYS are the transmit time delays (in s). DELAYS must be a vector or
%   matrix whose number of elements must be equal to the number of elements
%   in the array (which is equal to size(SIG,2)). If a sub-aperture was
%   used during transmission, use DELAYS(i) = NaN if element #i of the
%   linear array was off.
%
%   PARAM is a structure that contains the parameter values required for
%   DAS beamforming (see below for details).
%
%   In 3-D ultrasound imaging with a significant number of elements,
%   DASMTX3 can generate tall sparse DAS matrices when beamforming large
%   volume data! To avoid memory issues, consider chunking your datasets.
%
%   Let us consider that a series SIG{1}, SIG{2} ... SIG{N} of ultrasound
%   matrices have been generated by sending similar wavefronts with the
%   same array. To beamform these data with a delay-and-sum
%   approach, the following can be used:
%       M = dasmtx3(size(SIG),x,y,z,delays,param);
%       % (or M = dasmtx3(1i*size(SIG),...) for I/Q data)
%       for k = 1:N
%         bfSIG{k} = M*reshape(SIG{k},size(SIG{k},1),[]);
%         bfSIG{k} = reshape(bfSIG{k},size(x));
%       end
%   This syntax is much faster than:
%       for k = 1:N
%           bfSIG{k} = das3(SIG{k},x,y,z,delays,param);
%       end
%
%   DASMTX3(SIG,X,Y,Z,PARAM) uses DELAYS = param.TXdelay.
%
%   DASMTX3(...,METHOD) specifies the interpolation method. The available
%   methods are decribed in NOTE #3 below.
%
%   [M,PARAM] = DASMTX3(...) also returns the structure PARAM with the
%   default values.
%
%   ---
%   NOTE #1: X-, Y- and Z-axes
%   The migrated signals are calculated at the points specified by (X,Y,Z).
%   Conventional axes are used:
%   i) For a matrix array, the X-axis is PARALLEL to the transducer. The
%      Z-axis is PERPENDICULAR to the transducer and points downward (Z = 0
%      at the level of the transducer, Z increases as depth increases). The
%      Y-axis corresponds to the elevation direction.
%   ---
%   NOTE #2: DASMTX3 uses a standard delay-and-sum.
%   ---
%   NOTE #3: Interpolation methods
%   By default DASMTX3 uses a linear interpolation to generate the DAS
%   matrix. To specify the interpolation method, use DASMTX3(...,METHOD),
%   with METHOD being:
%      'nearest'   - nearest neighbor interpolation
%      'linear'    - (default) linear interpolation
%      'quadratic' - quadratic interpolation
%      'lanczos3'  - 3-lobe Lanczos (windowed sinc) interpolation
%      '5points'   - 5-point least-squares parabolic interpolation
%      'lanczos5'  - 5-lobe Lanczos (windowed sinc) interpolation
%
%   The linear interpolation (it is a 2-point method) returns a matrix
%   twice denser than the nearest-neighbor interpolation. It is 3, 4, 5, 6
%   times denser for 'quadratic', 'lanczos3', '5points', 'lanczos5',
%   respectively (they are 3-to-6-point methods).
%   ---
%
%   PARAM is a structure that contains the following fields:
%   -------------------------------------------------------
%   1)  PARAM.fs: sampling frequency (in Hz, REQUIRED)
%   2)  PARAM.elements: coordinates of the transducer elements (in m, REQUIRED)
%       PARAM.elements must contain the x- and y-coordinates of the
%       transducer elements (the z-coordinates are zero if not given). It
%       must be a matrix with 2 (or 3) rows corresponding to the
%       x- and y-coordinates (and optionally z), respectively.
%   3)  PARAM.fc: center frequency (in Hz, REQUIRED for I/Q signals)
%   4)  PARAM.TXdelay: transmission delays (in s, required if DELAYS is not given)
%   5)  PARAM.c: longitudinal velocity (in m/s, default = 1540 m/s)
%   6)  PARAM.t0: start time for reception (in s, default = 0 s)
%   7)  PARAM.fnumber: reception f-number (default = [0 0], i.e. full aperture)
%       PARAM.fnumber(1) = reception f-number in the azimuthal x-direction.
%       PARAM.fnumber(2) = reception f-number in the elevation y-direction.
%
%   Passive imaging
%   ---------------
%   8)  PARAM.passive: must be true for passive imaging (i.e. no transmit).
%       The default is false.
%
%   This function is part of MUST (Matlab UltraSound Toolbox).
%   MUST (c) 2020 Damien Garcia, LGPL-3.0-or-later
%
%   See also DAS, DASMTX, TXDELAY3, SIMUS3.
%
%   -- Adapted by François Varray & Raphaël Dumas from DASMTX -- 2020/10
%   -- Damien Garcia -- last update 2022/12/13
%   website: <a
%   href="matlab:web('http://www.biomecardio.com')">www.BiomeCardio.com</a>


%------------------------%
% CHECK THE INPUT SYNTAX %
%------------------------%

assert(nargin>4,'Not enough input arguments.')
assert(nargin<8,'Too many input arguments.')
assert(nargout<3,'Too many output arguments.')

assert(isequal(size(x),size(y),size(z)),'X, Y and Z must of same size.')
if isequal(size(SIG),[1 2]) || isequal(size(SIG),[1 3])
    nl = abs(SIG(1)); nc = abs(SIG(2));
else
    [nl,nc,~] = size(SIG);
end

% check if we have I/Q signals
isIQ = ~isreal(SIG);

%-- Check input parameters
if ischar(varargin{end})
    method = varargin{end};
    NArg = nargin-1;
else
    method = 'linear';
    NArg = nargin;
end

if NArg==5 % DASMTX3(SIG,x,y,z,param)
    if isstruct(varargin{1})
        param = varargin{1};
        param = IgnoreCaseInFieldNames(param);
    else
        error('The structure PARAM is required.')
    end
    assert(isfield(param,'TXdelay'),...
        'A TX delay vector (PARAM.TXdelay or DELAYS) is required.')
    delaysTX = param.TXdelay;
else % NArg=6: DASMTX3(SIG,x,y,z,delaysTX,param)
    delaysTX = varargin{1};
    param = varargin{2};
    assert(isstruct(param),'The structure PARAM is required.')
    param = IgnoreCaseInFieldNames(param);
end
if isfield(param,'TXdelay') % DASMTX3(SIG,x,y,z,delaysTX,param)
    assert(isequal(delaysTX(:),param.TXdelay(:)),...
        'If both specified, PARAM.TXdelay and DELAYS must be equal.')
end

%-- Interpolation method
if ~ismember(lower(method),{'nearest','linear','quadratic','lanczos3','5points','lanczos5'})
    error('METHOD must be ''nearest'', ''linear'', ''quadratic'', ''Lanczos3'', ''5points'' or ''Lanczos5''.')
end

%-- Propagation velocity (in m/s)
if ~isfield(param,'c')
    param.c = 1540; % longitudinal velocity in m/s
end

%-- Sampling frequency (in Hz)
if ~isfield(param,'fs')
    error('A sampling frequency (PARAM.fs) is required.')
end

%-- f-number
if ~isfield(param,'fnumber')
    param.fnumber = [0 0]; % f-number (default = full aperture)
elseif param.fnumber==0
    param.fnumber = [0 0];
elseif ~isempty(param.fnumber)
    assert(numel(param.fnumber)==2,...
        'PARAM.fnumber must contain two elements.')
    assert(isnumeric(param.fnumber),...
        'PARAM.fnumber must be numeric.')
    assert(all(param.fnumber>=0),...
        'PARAM.fnumber must be non-negative.')
end

%-- Acquisition start time (in s)
if ~isfield(param,'t0')
    param.t0 = 0; % acquisition start time in s
end

%-- Radius of curvature (in m)
% for a convex array
if ~isfield(param,'radius')
    param.radius = Inf; % default = linear array
else
    assert(isinf(param.radius),...
        'DASMTX3 does not address matrix convex arrays.')
end

%-- Reception angle (in rad) -- [option not available in DASMTX3] --
if ~isfield(param,'RXangle')
    param.RXangle = 0;
else
    assert(param.RXangle==0,...
        'PARAM.RXangle must be 0 with DASMTX3.')
end

%-- Passive imaging
if ~isfield(param,'passive')
    param.passive = false;
else
    assert(islogical(param.passive),...
        'PARAM.passive must be a boolean (false or true)')
end

%-- Coordinates of the transducer elements (xe,ye,ze)
assert(isfield(param,'elements'),...
    ['PARAM.elements must contain the x- and y-locations ',...
    'of the transducer elements.'])
assert(ismatrix(param.elements) &&...
    any(ismember([2 3],size(param.elements,1))),...
    ['PARAM.elements must be a 2 (or 3)-row matrix that contains the ',...
    'x, y (and optionally z)-coordinates of the transducer elements.'])
xe = param.elements(1,:);
ye = param.elements(2,:);
if size(param.elements,1)==3
    ze = param.elements(3,:);
else
    ze = zeros(size(xe));
end

%-- Number of elements
assert(numel(delaysTX)==nc,...
    'DELAYS and/or PARAM.TXdelay must be vectors of length size(SIG,2).')
% Note: param.Nelements can be required in other functions of the
%       Matlab Ultrasound Toolbox
if isfield(param,'Nelements')
    assert(param.Nelements==numel(delaysTX),...
        'PARAM.TXdelay or DELAYS must be of length PARAM.Nelements.')
end
assert(numel(xe)==nc,...
    'The number of elements must be equal to size(SIG,2).')

%-- Center frequency (in Hz)
if isIQ
    if isfield(param,'fc')
        if isfield(param,'f0')
            assert(abs(param.fc-param.f0)<eps,...
                ['A conflict exists for the center frequency:',13,...
                'PARAM.fc and PARAM.f0 are different!'])
        end
    elseif isfield(param,'f0')
        param.fc = param.f0; % Note: param.f0 can also be used
    else
        error('A center frequency (PARAM.fc) is required with I/Q data.')
    end
    wc = 2*pi*param.fc;
end


%-------------------------------%
% end of CHECK THE INPUT SYNTAX %
%-------------------------------%



% some parameters
fs = param.fs; % sampling frequency
c = param.c; % propagation velocity


%-- f-number (determined automatically if not given)
% The f-number is determined from the element directivity
% See the paper "So you think you can DAS?"
if isempty(param.fnumber)
    lambdaMIN = c/(param.fc*(1+param.bandwidth/200));
    RXa = abs(param.RXangle);
    % Note: in Matlab, sinc(x) = sin(pi*x)/(pi*x)
    f = @(th,width,lambda)...
        abs(cos(th+RXa)*sinc(width/lambda*sin(th+RXa))-0.71);
    % Note : 0.71 = 10^(dB/20), with dB = -3
    opt = optimset('TolX',pi/100);
    alpha = fminbnd(@(th) f(th,param.width,lambdaMIN),0,pi/2-RXa,opt);
    param.fnumber(1) = 1/2/tan(alpha);
    alpha = fminbnd(@(th) f(th,param.height,lambdaMIN),0,pi/2-RXa,opt);
    param.fnumber(2) = 1/2/tan(alpha);    
end
fNum = param.fnumber;


t0 = param.t0;
x = x(:); y = y(:); z = z(:);
Nx = numel(x);

%----
% Migration - diffraction summation (Delay & Sum, DAS)
%----

%-- TX and RX distances
dxT = x-xe; dyT = y-ye; dzT = z-ze;
dRX = sqrt(dxT.^2+dyT.^2+dzT.^2);
if ~param.passive
    dTX = min(delaysTX(:)'*c + dRX,[],2);
else
    dTX = 0;
end
clear x y z

%-- Travel times
tau = (dTX+dRX)/c;
clear dTX dRX

%-- Corresponding fast-time indices
idxt = (tau-t0(:)')*fs + 1;
idxt = double(idxt); % in case tau is in single precision

%-- In-range indices:
switch lower(method)
    case 'nearest', I = idxt>=1 & idxt<=nl;
    case 'linear', I = idxt>=1 & idxt<=nl-1;
    case 'quadratic', I = idxt>=1 & idxt<=nl-2;
    case 'lanczos3', I = idxt>=2 & idxt<=nl-2;
    case '5points', I = idxt>=3 & idxt<=nl-2;
    case 'lanczos5', I = idxt>=3 & idxt<=nl-3;
end

%-- Aperture (using the f-number):
if ~isequal(fNum(:),[0;0])
    % -- for a planar array
    Iaperture = abs(dxT)<=(abs(dzT)/2/fNum(1)) &...
        abs(dyT)<=(abs(dzT)/2/fNum(2));
    I = I&Iaperture;
end
clear dxT dyT dzT

% subscripts to linear indices (instead of using SUB2IND)
idx = idxt + (0:nc-1)*nl;
clear idxt
idx = idx(I);


%-- Let's fill in the sparse DAS matrix

if ~strcmpi(method,'nearest')
    idxf = floor(idx);
    idx = idx-idxf;
end
[i,~] = find(I);

switch lower(method) % Interpolation Method

    case 'nearest' %-- Nearest neighbor interpolation
        Npoints = 1; % 1-point method
        j = round(idx);
        s = 1;

    case 'linear' %-- Linear interpolation
        Npoints = 2; % 2-point method
        i = repmat(i,Npoints,1);
        j = [idxf; idxf+1];
        s = [-idx+1; idx];

    case 'quadratic' %-- quadratic interpolation
        Npoints = 3; % 3-point method
        i = repmat(i,Npoints,1);
        j = [idxf; idxf+1; idxf+2];
        s = [(idx-1).*(idx-2)/2;
            -idx.*(idx-2);
            idx.*(idx-1)/2];

    case 'lanczos3' %-- 3-lobe Lanczos interpolation
        Npoints = 4; % 4-point method
        i = repmat(i,Npoints,1);
        j = [idxf-1; idxf; idxf+1; idxf+2];
        s = [sinc(idx+1).*sinc((idx+1)/2);
            sinc(idx).*sinc(idx/2);
            sinc(idx-1).*sinc((idx-1)/2);
            sinc(idx-2).*sinc((idx-2)/2)];

    case '5points' %-- 5-point least-squares parabolic interpolation
        Npoints = 5; % 5-point method
        i = repmat(i,Npoints,1);
        j = [idxf-2; idxf-1; idxf; idxf+1; idxf+2];
        idx2 = idx.^2;
        s = [1/7*idx2-1/5*idx-3/35;
            -1/14*idx2-1/10*idx+12/35;
            -1/7*idx2+17/35;
            -1/14*idx2+1/10*idx+12/35;
            1/7*idx2+1/5*idx-3/35];

    case 'lanczos5' %-- 5-lobe Lanczos interpolation
        Npoints = 6; % 6-point method
        i = repmat(i,Npoints,1);
        j = [idxf-2; idxf-1; idxf; idxf+1; idxf+2; idxf+3];
        s = [sinc(idx+2).*sinc((idx+2)/2);
            sinc(idx+1).*sinc((idx+1)/2);
            sinc(idx).*sinc(idx/2);
            sinc(idx-1).*sinc((idx-1)/2);
            sinc(idx-2).*sinc((idx-2)/2);
            sinc(idx-3).*sinc((idx-3)/2)];
end

clear idx*

if isIQ % phase rotation (if I/Q signals)
    tau = tau(I);
    s = s.*exp(1i*wc*repmat(tau,Npoints,1));
end
clear tau

%-- DAS matrix (M)
M = s; clear s
M = sparse(i,j,M,Nx,nl*nc);
% M is a [numel(x)]-by-[nl*nc] sparse matrix


end



function structArray = IgnoreCaseInFieldNames(structArray)

switch inputname(1)
    case 'param'
        fieldLIST = {'attenuation','baffle','bandwidth','c','elements',...
            'fc','fnumber','fs','f0','image','kerf','Nelements',...
            'passive','pitch','radius','RXangle','RXdelay',...
            'TXapodization','TXdelay','TXfreqsweep','TXnow','t0','width'};
end

OldFieldNames = fieldnames(structArray);
tmp = lower(OldFieldNames);
assert(length(tmp)==length(unique(tmp)),...
    ['The structure ' upper(inputname(1)),...
    ' contains duplicate field names (when ignoring case).'])

[idx,loc] = ismember(lower(fieldLIST),tmp);
idx = find(idx); loc = loc(idx);
for k = 1:length(idx)
    tmp = eval(['structArray.' OldFieldNames{loc(k)}]); %#ok
    structArray = rmfield(structArray,OldFieldNames{loc(k)});
    eval(['structArray.' fieldLIST{idx(k)} ' = tmp;']) %#ok
end

end

